/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * MainPanel.java
 *
 * Created on Apr 19, 2013, 7:46:42 PM
 */
package com.project.ui;

import com.project.util.InputValidator;
import com.project.db.Database;
import com.project.db.Mysql;
import com.project.logger.Logs;
import com.project.util.Helper;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.sql.SQLException;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Scanner;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;

/**
 *
 * @author RavirajS
 */
public class MainPanel extends javax.swing.JPanel {

    public boolean testMaster = false;
    public boolean testDestination = false;
    public static boolean DEBUG;
    public String PREVIOUS_MASTER_DETAIL;
    public String PREVIOUS_DESTINATION_DETAIL;
    Database master;
    Database destination;

    /** Creates new form MainPanel */
    public MainPanel() {
        initComponents();
        DEBUG = true;
        PREVIOUS_MASTER_DETAIL = "master.d";
        PREVIOUS_DESTINATION_DETAIL = "destination.d";
        loadMasterDetails();
        loadDestinationDetails();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        jLabel14 = new javax.swing.JLabel();
        masterDBType = new javax.swing.JComboBox();
        masterHost = new javax.swing.JTextField();
        masterPort = new javax.swing.JTextField();
        masterDatabase = new javax.swing.JTextField();
        masterUser = new javax.swing.JTextField();
        masterPassword = new javax.swing.JPasswordField();
        masterTest = new javax.swing.JButton();
        destinationDBType = new javax.swing.JComboBox();
        destinationHost = new javax.swing.JTextField();
        destinationPort = new javax.swing.JTextField();
        destinationDatabase = new javax.swing.JTextField();
        destinationUser = new javax.swing.JTextField();
        destinationPassword = new javax.swing.JPasswordField();
        destinationTest = new javax.swing.JButton();
        startCompareForeignKeys = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        upgradeProgressBar = new javax.swing.JProgressBar();
        startUpgrade = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        startCompareSchema = new javax.swing.JButton();
        upgradeProgressBar1 = new javax.swing.JProgressBar();
        jPanel3 = new javax.swing.JPanel();
        startPrimaryKeyCompare = new javax.swing.JButton();
        upgradeProgressBar2 = new javax.swing.JProgressBar();
        jPanel4 = new javax.swing.JPanel();
        startForeignKeyCompare = new javax.swing.JButton();
        upgradeProgressBar3 = new javax.swing.JProgressBar();
        jPanel5 = new javax.swing.JPanel();
        startUniqueKeyCompare = new javax.swing.JButton();
        upgradeProgressBar4 = new javax.swing.JProgressBar();
        status = new javax.swing.JLabel();
        debug = new javax.swing.JCheckBox();

        setLayout(null);

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabel1.setText("Source Master Database");
        add(jLabel1);
        jLabel1.setBounds(20, 30, 210, 15);

        jLabel2.setText("Database Type");
        add(jLabel2);
        jLabel2.setBounds(20, 60, 120, 14);

        jLabel3.setText("Host Address");
        add(jLabel3);
        jLabel3.setBounds(20, 90, 120, 14);

        jLabel4.setText("Port");
        add(jLabel4);
        jLabel4.setBounds(20, 120, 120, 14);

        jLabel5.setText("Database");
        add(jLabel5);
        jLabel5.setBounds(20, 150, 120, 14);

        jLabel6.setText("Password");
        add(jLabel6);
        jLabel6.setBounds(20, 210, 120, 14);

        jLabel7.setText("User");
        add(jLabel7);
        jLabel7.setBounds(20, 180, 120, 14);

        jLabel8.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabel8.setText("Destination Upgrade Database");
        add(jLabel8);
        jLabel8.setBounds(420, 30, 230, 15);

        jLabel9.setText("Database Type");
        add(jLabel9);
        jLabel9.setBounds(420, 60, 120, 14);

        jLabel10.setText("Host Address");
        add(jLabel10);
        jLabel10.setBounds(420, 90, 120, 14);

        jLabel11.setText("Port");
        add(jLabel11);
        jLabel11.setBounds(420, 120, 120, 14);

        jLabel12.setText("Database");
        add(jLabel12);
        jLabel12.setBounds(420, 150, 120, 14);

        jLabel13.setText("User");
        add(jLabel13);
        jLabel13.setBounds(420, 180, 120, 14);

        jLabel14.setText("Password");
        add(jLabel14);
        jLabel14.setBounds(420, 210, 120, 14);

        masterDBType.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "MySQL" }));
        add(masterDBType);
        masterDBType.setBounds(160, 60, 120, 20);

        masterHost.addInputMethodListener(new java.awt.event.InputMethodListener() {
            public void caretPositionChanged(java.awt.event.InputMethodEvent evt) {
            }
            public void inputMethodTextChanged(java.awt.event.InputMethodEvent evt) {
                masterHostInputMethodTextChanged(evt);
            }
        });
        masterHost.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                masterHostKeyReleased(evt);
            }
        });
        add(masterHost);
        masterHost.setBounds(160, 90, 120, 20);

        masterPort.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                masterPortKeyReleased(evt);
            }
        });
        add(masterPort);
        masterPort.setBounds(160, 120, 120, 20);

        masterDatabase.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                masterDatabaseKeyReleased(evt);
            }
        });
        add(masterDatabase);
        masterDatabase.setBounds(160, 150, 120, 20);

        masterUser.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                masterUserKeyReleased(evt);
            }
        });
        add(masterUser);
        masterUser.setBounds(160, 180, 120, 20);

        masterPassword.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                masterPasswordKeyReleased(evt);
            }
        });
        add(masterPassword);
        masterPassword.setBounds(160, 210, 120, 20);

        masterTest.setText("Test");
        masterTest.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                masterTestActionPerformed(evt);
            }
        });
        add(masterTest);
        masterTest.setBounds(120, 250, 120, 40);

        destinationDBType.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "MySQL" }));
        add(destinationDBType);
        destinationDBType.setBounds(560, 60, 120, 20);

        destinationHost.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                destinationHostKeyReleased(evt);
            }
        });
        add(destinationHost);
        destinationHost.setBounds(560, 90, 120, 20);

        destinationPort.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                destinationPortKeyReleased(evt);
            }
        });
        add(destinationPort);
        destinationPort.setBounds(560, 120, 120, 20);

        destinationDatabase.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                destinationDatabaseKeyReleased(evt);
            }
        });
        add(destinationDatabase);
        destinationDatabase.setBounds(560, 150, 120, 20);

        destinationUser.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                destinationUserKeyReleased(evt);
            }
        });
        add(destinationUser);
        destinationUser.setBounds(560, 180, 120, 20);

        destinationPassword.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                destinationPasswordKeyReleased(evt);
            }
        });
        add(destinationPassword);
        destinationPassword.setBounds(560, 210, 120, 20);

        destinationTest.setText("Test");
        destinationTest.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                destinationTestActionPerformed(evt);
            }
        });
        add(destinationTest);
        destinationTest.setBounds(480, 250, 120, 40);

        startCompareForeignKeys.setTabLayoutPolicy(javax.swing.JTabbedPane.SCROLL_TAB_LAYOUT);

        jPanel1.setLayout(null);
        jPanel1.add(upgradeProgressBar);
        upgradeProgressBar.setBounds(240, 80, 150, 14);

        startUpgrade.setText("Start Upgrade");
        startUpgrade.setEnabled(false);
        startUpgrade.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startUpgradeActionPerformed(evt);
            }
        });
        jPanel1.add(startUpgrade);
        startUpgrade.setBounds(240, 10, 150, 60);

        startCompareForeignKeys.addTab("Schema Upgrade", jPanel1);

        jPanel2.setLayout(null);

        startCompareSchema.setText("Start Compare");
        startCompareSchema.setEnabled(false);
        startCompareSchema.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startCompareSchemaActionPerformed(evt);
            }
        });
        jPanel2.add(startCompareSchema);
        startCompareSchema.setBounds(240, 10, 150, 60);
        jPanel2.add(upgradeProgressBar1);
        upgradeProgressBar1.setBounds(240, 80, 150, 14);

        startCompareForeignKeys.addTab("Schema Compare", jPanel2);

        jPanel3.setLayout(null);

        startPrimaryKeyCompare.setText("Start Compare");
        startPrimaryKeyCompare.setEnabled(false);
        startPrimaryKeyCompare.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startPrimaryKeyCompareActionPerformed(evt);
            }
        });
        jPanel3.add(startPrimaryKeyCompare);
        startPrimaryKeyCompare.setBounds(240, 10, 150, 60);
        jPanel3.add(upgradeProgressBar2);
        upgradeProgressBar2.setBounds(240, 80, 150, 14);

        startCompareForeignKeys.addTab("Compare Primary Keys", jPanel3);

        jPanel4.setLayout(null);

        startForeignKeyCompare.setText("Start Compare");
        startForeignKeyCompare.setEnabled(false);
        startForeignKeyCompare.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startForeignKeyCompareActionPerformed(evt);
            }
        });
        jPanel4.add(startForeignKeyCompare);
        startForeignKeyCompare.setBounds(240, 10, 150, 60);
        jPanel4.add(upgradeProgressBar3);
        upgradeProgressBar3.setBounds(240, 80, 150, 14);

        startCompareForeignKeys.addTab("Compare Foreign Keys", jPanel4);

        jPanel5.setLayout(null);

        startUniqueKeyCompare.setText("Start Compare");
        startUniqueKeyCompare.setEnabled(false);
        startUniqueKeyCompare.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startUniqueKeyCompareActionPerformed(evt);
            }
        });
        jPanel5.add(startUniqueKeyCompare);
        startUniqueKeyCompare.setBounds(240, 10, 150, 60);
        jPanel5.add(upgradeProgressBar4);
        upgradeProgressBar4.setBounds(240, 80, 150, 14);

        startCompareForeignKeys.addTab("Compare Unique Keys", jPanel5);

        add(startCompareForeignKeys);
        startCompareForeignKeys.setBounds(10, 320, 730, 130);

        status.setText("Ready");
        add(status);
        status.setBounds(10, 460, 590, 14);

        debug.setText("debug");
        debug.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                debugStateChanged(evt);
            }
        });
        add(debug);
        debug.setBounds(660, 460, 81, 23);
    }// </editor-fold>//GEN-END:initComponents

    private void masterTestActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_masterTestActionPerformed
        // TODO add your handling code here:
        freezeElements(true);
        if (verifyMaster()) {
            //String databaseType = (String) masterDBType.getSelectedItem();
            String databaseHost = masterHost.getText();
            String databasePort = masterPort.getText();
            String databaseName = masterDatabase.getText();
            String databaseUser = masterUser.getText();
            String databasePassword = new String(masterPassword.getPassword());
            master = new Mysql(databaseHost, databasePort, databaseName, databaseUser, databasePassword);
            saveMasterDetails();
            if (master.testConnection()) {
                SwingUtilities.invokeLater(new Runnable() {

                    public void run() {
                        JOptionPane.showMessageDialog(null, "Connection successful!");
                    }
                });
                testMaster = true;
            }
        }
        freezeElements(false);
    }//GEN-LAST:event_masterTestActionPerformed

    public void setProcessButtonsEnabled(final boolean value) {
        SwingUtilities.invokeLater(new Runnable() {

            public void run() {
                startUpgrade.setEnabled(value);
                startCompareSchema.setEnabled(value);
                startPrimaryKeyCompare.setEnabled(value);
                startForeignKeyCompare.setEnabled(value);
                startUniqueKeyCompare.setEnabled(value);
            }
        });

    }
    private void destinationTestActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_destinationTestActionPerformed
        // TODO add your handling code here:
        freezeElements(true);
        if (verifyDestination()) {
            //String databaseType = (String) destinationDBType.getSelectedItem();
            String databaseHost = destinationHost.getText();
            String databasePort = destinationPort.getText();
            String databaseName = destinationDatabase.getText();
            String databaseUser = destinationUser.getText();
            String databasePassword = new String(destinationPassword.getPassword());
            destination = new Mysql(databaseHost, databasePort, databaseName, databaseUser, databasePassword);
            saveDestinationDetails();
            if (destination.testConnection()) {
                SwingUtilities.invokeLater(new Runnable() {

                    public void run() {
                        JOptionPane.showMessageDialog(null, "Connection successful!");
                    }
                });
                testDestination = true;
            }
        }
        freezeElements(false);
    }//GEN-LAST:event_destinationTestActionPerformed

    public static void updateStatus(final String message) {
        SwingUtilities.invokeLater(new Runnable() {

            public void run() {
                status.setText(message);
            }
        });
    }

    private void startUpgradeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startUpgradeActionPerformed
        freezeElements(true);
        try {
            Vector<String> queryContainer = new Vector<String>();
            //First we will compare existing tables and upgrade the existing fields by adding new columns and updating datatypes
            Logs.write("Start: Processing Queries For Existing Columns Differences");
            updateStatus("Processing Queries For Existing Columns Differences");
            //queryContainer.addAll(getAlterQueriesForExistingColumns());
            queryContainer.addAll(getAlterQueriesForExistingColumns());
            Logs.write("End: Processing Queries For Existing Columns Differences");

            Logs.write("Start: Processing Queries For Missing Columns Differences");
            updateStatus("Processing Queries For Missing Columns Differences");
            //queryContainer.addAll(getAlterQueriesForMissingColumns());
            queryContainer.addAll(getAlterQueriesForMissingColumns());
            Logs.write("End: Processing Queries For Missing Columns Differences");

            //Second step we will compare for missing tables and add those missing tables in destination database
            Logs.write("Start: Processing For Missing Tables");
            updateStatus("Processing For Missing Tables");
            queryContainer.addAll(getCreateQueriesForMissingTables());
            Logs.write("End: Processing For Missing Tables");

            //Third step we will compare Unique keys and add Unique keys to destination tables
            Logs.write("Start: Processing For Existing Unique Keys Differences");
            updateStatus("Processing For Existing Unique Keys Differences");
            queryContainer.addAll(getAlterQueriesForExistingUniquekeys());
            Logs.write("End: Processing For Existing Unique Keys Differences");

            Logs.write("Start: Processing For Missing Unique Keys");
            updateStatus("Processing For Missing Unique Keys");
            queryContainer.addAll(getAlterQueriesForMissingUniquekeys());
            Logs.write("End: Processing For Missing Unique Keys");

            //Fourth step we will compare Primary Keys and add primary keys to the destination tables
            Logs.write("Start: Processing For Missing Primary Keys");
            updateStatus("Processing For Missing Primary Keys");
            queryContainer.addAll(getAlterQueriesForMissingPrimaryKeys());
            Logs.write("End: Processing For Missing Primary Keys");

            //Fifth step we will compare Foreign Keys and add Foreign keys to destination tables
            Logs.write("Start: Processing For Missing Foreign Keys");
            updateStatus("Processing For Missing Foreign Keys");
            queryContainer.addAll(getAlterQueriesForMissingForeignKeys());
            Logs.write("End: Processing For Missing Foreign Keys");

            destination.execute(queryContainer);

            try {
                Helper.writeVectorContentsInFile("generatedQueries.txt", queryContainer);
            } catch (FileNotFoundException fnfe) {
                Logs.write("Error while writing in testresult file", fnfe);
            }

        } catch (ClassNotFoundException cnfe) {
            Logs.write("Connection driver missing", cnfe);
            updateStatus("Connection driver missing");
        } catch (SQLException sqle) {
            Logs.write("Error Executing Query", sqle);
            updateStatus("Error Executing Query");
        }
        updateStatus("Done");
        freezeElements(false);
//        try {
        //Sixth step we will compare custom primary keys
        //Sixth step we will compare Indexes and add missing Indexes to destination tables
        //destination.execute(queryContainer);
//        } catch (ClassNotFoundException cnfe) {
//            Logs.write("Connection driver missing", cnfe);
//        } catch (SQLException sqle) {
//            Logs.write("Error Executing Query", sqle);
//        }
//        try {
//            Helper.writeVectorContentsInFile("generatedQueries.txt", queryContainer);
//        } catch (FileNotFoundException fnfe) {
//            Logs.write("Error while writing in testresult file", fnfe);
//        }






    }//GEN-LAST:event_startUpgradeActionPerformed

    private void startCompareSchemaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startCompareSchemaActionPerformed
        freezeElements(true);
        try {
            Vector<String> title = new Vector<String>();
            title.add("MASTER TABLE NAME");
            title.add("DATA TYPE");
            title.add("DEFAULT VALUE");
            title.add("IS NULLABLE");
            title.add("DESTINATION TABLE NAME");
            title.add("DATA TYPE");
            title.add("DEFAULT VALUE");
            title.add("IS NULLABLE");
            title.add("RESULT");
            Vector<Object> result = getColumnDifference(master, destination);
            TableView view = new TableView(result, title);
            view.setSize(850, 480);
            view.setVisible(true);

        } catch (SQLException sqle) {
            JOptionPane.showMessageDialog(null, "SQL Exception");
            Logs.write("SQL Exception", sqle);
        } catch (ClassNotFoundException cnfe) {
            JOptionPane.showMessageDialog(null, "Driver not found");
            Logs.write("Driver not found", cnfe);
        }
        freezeElements(false);
    }//GEN-LAST:event_startCompareSchemaActionPerformed

    public Vector<Object> getColumnDifference(Database master, Database destination) throws SQLException, ClassNotFoundException {
        Vector<Object> columnInfo = new Vector<Object>();
        Vector<String> tablesList = master.getTablesList();
        Enumeration enumerate = tablesList.elements();


        while (enumerate.hasMoreElements()) {
            String tableName = (String) enumerate.nextElement();
            Vector<String> masterColumnList = master.getColumnsList(tableName, false);
            Enumeration<String> masterColumns = masterColumnList.elements();
            while (masterColumns.hasMoreElements()) {
                String masterColumn = masterColumns.nextElement();
                HashMap<String, String> masterColumnProperties = master.getColumnProperties(tableName, masterColumn);
                Vector<String> row = new Vector<String>();
                row.add(tableName + "." + masterColumn);
                String masterColumnDataType = masterColumnProperties.get("DATA_TYPE");
                row.add(masterColumnDataType);
                String masterColumnDefaultValue = masterColumnProperties.get("DEFAULT_VALUE");
                if (masterColumnDefaultValue == null) {
                    masterColumnDefaultValue = "null";
                }
                row.add(masterColumnDefaultValue);
                String masterColumnIsNullable = masterColumnProperties.get("IS_NULLABLE");
                row.add(masterColumnIsNullable);
                //System.out.println(row);

                Vector<String> destinationColumnList = destination.getColumnsList(tableName, false);

                if (destinationColumnList.contains(masterColumn)) {
                    HashMap<String, String> destinationColumnProperties = destination.getColumnProperties(tableName, masterColumn);
                    row.add(tableName + "." + masterColumn);
                    String destinationColumnDataType = destinationColumnProperties.get("DATA_TYPE");
                    row.add(destinationColumnDataType);
                    String destinationColumnDefaultValue = destinationColumnProperties.get("DEFAULT_VALUE");
                    if (destinationColumnDefaultValue == null) {
                        destinationColumnDefaultValue = "null";
                    }
                    row.add(destinationColumnDefaultValue);
                    String destinationColumnIsNullable = destinationColumnProperties.get("IS_NULLABLE");
                    row.add(destinationColumnIsNullable);
                    if (masterColumnDataType.equals(destinationColumnDataType) || masterColumnDefaultValue.equals(destinationColumnDefaultValue) || masterColumnIsNullable.equals(destinationColumnIsNullable)) {
                        row.add("OK");
                    } else {
                        row.add("MISMATCH");
                    }
                } else {
                    row.add("-");
                    row.add("-");
                    row.add("-");
                    row.add("-");
                    row.add("MISSING");
                }
                columnInfo.add(row);
            }
        }
        return columnInfo;
    }

    private void startPrimaryKeyCompareActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startPrimaryKeyCompareActionPerformed
        freezeElements(true);
        try {
            Vector<String> title = new Vector<String>();
            title.add("MASTER TABLE NAME");
            title.add("MASTER COLUMN NAME");
            title.add("DESTINATION TABLE NAME");
            title.add("DESTINATION COLUMN NAME");
            title.add("RESULT");
            Vector<Object> result = getPrimaryKeyDifference(master, destination);
            TableView view = new TableView(result, title);
            view.setSize(850, 480);
            view.setVisible(true);
        } catch (SQLException ex) {
            JOptionPane.showConfirmDialog(null, "SQL Exception", "Error", JOptionPane.ERROR_MESSAGE);
        } catch (ClassNotFoundException ex) {
            JOptionPane.showConfirmDialog(null, "Driver not found", "Error", JOptionPane.ERROR_MESSAGE);
        }
        freezeElements(false);
    }//GEN-LAST:event_startPrimaryKeyCompareActionPerformed

    private void startForeignKeyCompareActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startForeignKeyCompareActionPerformed
        freezeElements(true);
        try {
            Vector<String> title = new Vector<String>();
            title.add("MASTER CONSTRAINT NAME");
            title.add("TABLE NAME");
            title.add("COLUMN NAME");
            title.add("REF TABLE NAME");
            title.add("REF COLUMN NAME");
            title.add("DESTINATION CONSTRAINT NAME");
            title.add("TABLE NAME");
            title.add("COLUMN NAME");
            title.add("REF TABLE NAME");
            title.add("REF COLUMN NAME");
            title.add("RESULT");
            Vector<Object> result = getForeignKeyDifference(master, destination);
            TableView view = new TableView(result, title);
            view.setSize(850, 480);
            view.setVisible(true);

        } catch (SQLException ex) {
            JOptionPane.showConfirmDialog(null, "SQL Exception", "Error", JOptionPane.ERROR_MESSAGE);
        } catch (ClassNotFoundException ex) {
            JOptionPane.showConfirmDialog(null, "Driver not found", "Error", JOptionPane.ERROR_MESSAGE);
        }
        freezeElements(false);
    }//GEN-LAST:event_startForeignKeyCompareActionPerformed

    private void startUniqueKeyCompareActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startUniqueKeyCompareActionPerformed
        freezeElements(true);
        try {
            Vector<String> title = new Vector<String>();
            title.add("MASTER CONSTRAINT NAME");
            title.add("MASTER TABLE NAME");
            title.add("MASTER COLUMN NAME");
            title.add("DESINATION CONSTRAINT NAME");
            title.add("DESTINATION TABLE NAME");
            title.add("DESTINATION COLUMN NAME");
            title.add("RESULT");
            Vector<Object> result = getUniqueKeyDifference(master, destination);
            TableView view = new TableView(result, title);
            view.setSize(850, 480);
            view.setVisible(true);

        } catch (SQLException ex) {
            JOptionPane.showConfirmDialog(null, "SQL Exception", "Error", JOptionPane.ERROR_MESSAGE);
        } catch (ClassNotFoundException ex) {
            JOptionPane.showConfirmDialog(null, "Driver not found", "Error", JOptionPane.ERROR_MESSAGE);
        }
        freezeElements(false);
    }//GEN-LAST:event_startUniqueKeyCompareActionPerformed

    private void debugStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_debugStateChanged
        if (debug.isSelected()) {
            DEBUG = true;
        } else {
            DEBUG = false;
        }
    }//GEN-LAST:event_debugStateChanged

    private void masterHostInputMethodTextChanged(java.awt.event.InputMethodEvent evt) {//GEN-FIRST:event_masterHostInputMethodTextChanged
        // TODO add your handling code here:
    }//GEN-LAST:event_masterHostInputMethodTextChanged

    private void masterHostKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_masterHostKeyReleased
        // TODO add your handling code here:

        testMaster = false;
        setProcessButtonsEnabled(false);
    }//GEN-LAST:event_masterHostKeyReleased

    private void masterPortKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_masterPortKeyReleased
        // TODO add your handling code here:

        testMaster = false;
        setProcessButtonsEnabled(false);
    }//GEN-LAST:event_masterPortKeyReleased

    private void masterDatabaseKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_masterDatabaseKeyReleased
        // TODO add your handling code here:

        testMaster = false;
        setProcessButtonsEnabled(false);
    }//GEN-LAST:event_masterDatabaseKeyReleased

    private void masterUserKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_masterUserKeyReleased
        // TODO add your handling code here:testMaster = false;

        testMaster = false;
        setProcessButtonsEnabled(false);
    }//GEN-LAST:event_masterUserKeyReleased

    private void masterPasswordKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_masterPasswordKeyReleased
        // TODO add your handling code here:

        testMaster = false;
        setProcessButtonsEnabled(false);
    }//GEN-LAST:event_masterPasswordKeyReleased

    private void destinationHostKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_destinationHostKeyReleased
        // TODO add your handling code here:

        testDestination = false;
        setProcessButtonsEnabled(false);
    }//GEN-LAST:event_destinationHostKeyReleased

    private void destinationPortKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_destinationPortKeyReleased
        // TODO add your handling code here:

        testDestination = false;
        setProcessButtonsEnabled(false);
    }//GEN-LAST:event_destinationPortKeyReleased

    private void destinationDatabaseKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_destinationDatabaseKeyReleased
        // TODO add your handling code here:

        testDestination = false;
        setProcessButtonsEnabled(false);
    }//GEN-LAST:event_destinationDatabaseKeyReleased

    private void destinationUserKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_destinationUserKeyReleased
        // TODO add your handling code here:

        testDestination = false;
        setProcessButtonsEnabled(false);
    }//GEN-LAST:event_destinationUserKeyReleased

    private void destinationPasswordKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_destinationPasswordKeyReleased
        // TODO add your handling code here:

        testDestination = false;
        setProcessButtonsEnabled(false);
    }//GEN-LAST:event_destinationPasswordKeyReleased

    public Vector<Object> getPrimaryKeyDifference(Database master, Database destination) throws SQLException, ClassNotFoundException {
        Vector<Object> columnInfo = new Vector<Object>();
        HashMap<String, String> masterPrimaryKeyList = master.getPrimaryKeys();
        Set<String> primaryTableSet = masterPrimaryKeyList.keySet();

        Iterator<String> itr = primaryTableSet.iterator();

        while (itr.hasNext()) {
            String tableName = itr.next();
            Vector<String> row = new Vector<String>();
            String masterPrimaryColumnName = masterPrimaryKeyList.get(tableName);
            row.add(tableName);
            row.add(masterPrimaryColumnName);

            HashMap<String, String> destinationPrimaryKeyList = destination.getPrimaryKeys();
            Set<String> destinationTableSet = destinationPrimaryKeyList.keySet();

            if (destinationTableSet.contains(tableName)) {
                row.add(tableName);
                String destinationPrimaryColumnName = destinationPrimaryKeyList.get(tableName);
                row.add(destinationPrimaryColumnName);
                if (masterPrimaryColumnName.equals(destinationPrimaryColumnName)) {
                    row.add("OK");
                } else {
                    row.add("MISMATCH");
                }
            } else {
                row.add("-");
                row.add("-");
                row.add("MISSING");
            }
            columnInfo.add(row);
        }
        return columnInfo;
    }

    public Vector<Object> getUniqueKeyDifference(Database master, Database destination) throws SQLException, ClassNotFoundException {
        Vector<Object> columnInfo = new Vector<Object>();
        Vector<String> masterUniqueKeyList = master.getUniqueKeys();
        Enumeration masters = masterUniqueKeyList.elements();


        while (masters.hasMoreElements()) {
            Vector<String> row = new Vector<String>();
            String masterUniqueConstraintName = (String) masters.nextElement();
            Vector<String> masterUniqueKeyColumnList = master.getUniqueKeyColumns(masterUniqueConstraintName);
            row.add(masterUniqueConstraintName);
            String masterTableName = master.getTableNameForConstraint(masterUniqueConstraintName);
            row.add(masterTableName);
            String masterColumnNamesInCSV = Helper.convertVetorToCSV(masterUniqueKeyColumnList);
            row.add(masterColumnNamesInCSV);

            Vector<String> destinationUniqueKeyList = destination.getUniqueKeys();


            if (destinationUniqueKeyList.contains(masterUniqueConstraintName)) {
                Vector<String> destinationUniqueKeyColumnList = destination.getUniqueKeyColumns(masterUniqueConstraintName);
                row.add(masterUniqueConstraintName);
                String destinationTableName = destination.getTableNameForConstraint(masterUniqueConstraintName);
                row.add(destinationTableName);
                String destinationColumnNamesInCSV = Helper.convertVetorToCSV(destinationUniqueKeyColumnList);
                row.add(destinationColumnNamesInCSV);
                if (masterColumnNamesInCSV.equals(destinationColumnNamesInCSV)) {
                    row.add("OK");
                } else {
                    row.add("MISMATCH");
                }

            } else {
                row.add("-");
                row.add("-");
                row.add("-");
                row.add("MISSING");
            }
            columnInfo.add(row);
        }
        return columnInfo;
    }

    public void freezeElements(boolean value) {
        if (value) {
            setProcessButtonsEnabled(false);
        } else {
            if (testMaster && testDestination) {
                setProcessButtonsEnabled(true);
            } else {
                setProcessButtonsEnabled(false);
            }
        }
        setDatabaseDetailsEnabled(!value);

    }

    public void setDatabaseDetailsEnabled(final boolean value) {
        SwingUtilities.invokeLater(new Runnable() {

            public void run() {
                masterDBType.setEnabled(value);
                masterHost.setEnabled(value);
                masterPort.setEnabled(value);
                masterDatabase.setEnabled(value);
                masterUser.setEnabled(value);
                masterPassword.setEnabled(value);
                masterTest.setEnabled(value);
                destinationDBType.setEnabled(value);
                destinationHost.setEnabled(value);
                destinationPort.setEnabled(value);
                destinationDatabase.setEnabled(value);
                destinationUser.setEnabled(value);
                destinationPassword.setEnabled(value);
                destinationTest.setEnabled(value);
            }
        });
    }

    public Vector<Object> getForeignKeyDifference(Database master, Database destination) throws SQLException, ClassNotFoundException {
        Vector<Object> columnInfo = new Vector<Object>();
        Vector<String> masterForeigneKeyList = master.getForeignKeys();
        Enumeration masters = masterForeigneKeyList.elements();


        while (masters.hasMoreElements()) {
            Vector<String> row = new Vector<String>();
            String masterForeignConstraintName = (String) masters.nextElement();
            HashMap<String, String> masterForeignKeyProperties = master.getForeignKeyReference(masterForeignConstraintName);
            row.add(masterForeignConstraintName);
            String masterForeignKeyTableName = masterForeignKeyProperties.get("TABLE_NAME");
            row.add(masterForeignKeyTableName);
            String masterForeignKeyColumnName = masterForeignKeyProperties.get("COLUMN_NAME");
            row.add(masterForeignKeyColumnName);
            String masterForeignKeyRefTableName = masterForeignKeyProperties.get("REFERENCE_TABLE_NAME");
            row.add(masterForeignKeyRefTableName);
            String masterForeignKeyRefColumnName = masterForeignKeyProperties.get("REFERENCE_COLUMN_NAME");
            row.add(masterForeignKeyRefColumnName);

            Vector<String> destinationForeignKeyList = destination.getForeignKeys();

            if (destinationForeignKeyList.contains(masterForeignConstraintName)) {
                HashMap<String, String> destinationForeignKeyProperties = master.getForeignKeyReference(masterForeignConstraintName);
                row.add(masterForeignConstraintName);
                String destinationForeignKeyTableName = destinationForeignKeyProperties.get("TABLE_NAME");
                row.add(destinationForeignKeyTableName);
                String destinationForeignKeyColumnName = destinationForeignKeyProperties.get("COLUMN_NAME");
                row.add(destinationForeignKeyColumnName);
                String destinationForeignKeyRefTableName = destinationForeignKeyProperties.get("REFERENCE_TABLE_NAME");
                row.add(destinationForeignKeyRefTableName);
                String destinationForeignKeyRefColumnName = destinationForeignKeyProperties.get("REFERENCE_COLUMN_NAME");
                row.add(destinationForeignKeyRefColumnName);
                if (masterForeignKeyTableName.equals(destinationForeignKeyTableName) || masterForeignKeyColumnName.equals(destinationForeignKeyColumnName) || masterForeignKeyRefTableName.equals(destinationForeignKeyRefTableName) || masterForeignKeyRefColumnName.equals(destinationForeignKeyRefColumnName)) {
                    row.add("OK");
                } else {
                    row.add("MISMATCH");
                }

            } else {
                row.add("-");
                row.add("-");
                row.add("-");
                row.add("-");
                row.add("MISSING");
            }
            columnInfo.add(row);
        }
        return columnInfo;
    }

    public Vector<String> getMissingTables() throws ClassNotFoundException, SQLException {
        Vector<String> masterTables = master.getTablesList();
        Vector<String> destinationTables = destination.getTablesList();
        masterTables.removeAll(destinationTables);
        return masterTables;
    }

    public Vector<String> getExistingTables() throws ClassNotFoundException, SQLException {
        Vector<String> masterTables = master.getTablesList();
        masterTables.removeAll(getMissingTables());
        return masterTables;
    }

    public Vector<String> getMissingColumnsFromTable(String tableName) throws ClassNotFoundException, SQLException {
        Vector<String> masterColumns = master.getColumnsList(tableName, false);
        Vector<String> destinationColumns = destination.getColumnsList(tableName, false);
        masterColumns.removeAll(destinationColumns);
        return masterColumns;
    }

    public Vector<String> getExistingColumnsFromTable(String tableName) throws ClassNotFoundException, SQLException {
        Vector<String> masterColumns = master.getColumnsList(tableName, false);
        masterColumns.removeAll(getMissingColumnsFromTable(tableName));
        return masterColumns;
    }

    public Vector<String> getMissingUniqueKeys() throws ClassNotFoundException, SQLException {
        Vector<String> masterUniqueKeys = master.getUniqueKeys();
        Vector<String> destinationUniqueKeys = destination.getUniqueKeys();
        masterUniqueKeys.removeAll(destinationUniqueKeys);
        return masterUniqueKeys;
    }

    public Vector<String> getExistingUniqueKeys() throws ClassNotFoundException, SQLException {
        Vector<String> masterUniqueKeys = master.getUniqueKeys();
        masterUniqueKeys.removeAll(getMissingUniqueKeys());
        return masterUniqueKeys;
    }

    public HashMap<String, String> getMissingPrimaryKeys() throws ClassNotFoundException, SQLException {
        HashMap<String, String> masterPrimaryKeys = master.getPrimaryKeys();
        HashMap<String, String> destinationPrimaryKeys = destination.getPrimaryKeys();
        Set<String> destinationKeySet = destinationPrimaryKeys.keySet();
        Iterator destinationKeys = destinationKeySet.iterator();
        while (destinationKeys.hasNext()) {
            masterPrimaryKeys.remove((String) destinationKeys.next());
        }
        return masterPrimaryKeys;
    }

    public Vector<String> getMissingForeignKeys() throws ClassNotFoundException, SQLException {
        Vector<String> masterForeignKeys = master.getForeignKeys();
        Vector<String> destinationForeignKeys = destination.getForeignKeys();
        masterForeignKeys.removeAll(destinationForeignKeys);
        return masterForeignKeys;
    }

    public Vector<String> getExistingForeignKeys() throws ClassNotFoundException, SQLException {
        Vector<String> masterForeignKeys = master.getForeignKeys();
        masterForeignKeys.removeAll(getMissingForeignKeys());
        return masterForeignKeys;
    }

//    public Vector<String> getAlterQueriesForExistingColumns() throws ClassNotFoundException, SQLException {
//        Vector<String> queries = new Vector<String>();
//        Vector<String> existingTables = getExistingTables();
//        Enumeration<String> tables = existingTables.elements();
//        while (tables.hasMoreElements()) {
//            String tableName = tables.nextElement();
//
//            Vector<String> existingColumns = getExistingColumnsFromTable(tableName);
//            Enumeration<String> columns = existingColumns.elements();
//            while (columns.hasMoreElements()) {
//                String column = columns.nextElement();
//
//                HashMap<String, String> masterColumnPropertiesMap = master.getColumnProperties(tableName, column);
//                HashMap<String, String> destinationColumnPropertiesMap = destination.getColumnProperties(tableName, column);
//                boolean test = true;
//                if (!masterColumnPropertiesMap.get("DATA_TYPE").equals(destinationColumnPropertiesMap.get("DATA_TYPE"))) {
//                    test = false;
//                } else if (!masterColumnPropertiesMap.get("COLUMN_SIZE").equals(destinationColumnPropertiesMap.get("COLUMN_SIZE"))) {
//                    test = false;
//                } else if (!masterColumnPropertiesMap.get("DECIMAL_DIGITS").equals(destinationColumnPropertiesMap.get("DECIMAL_DIGITS"))) {
//                    test = false;
//                } else if (!masterColumnPropertiesMap.get("IS_NULLABLE").equals(destinationColumnPropertiesMap.get("IS_NULLABLE"))) {
//                    test = false;
//                } else if (!masterColumnPropertiesMap.get("IS_AUTOINCREMENT").equals(destinationColumnPropertiesMap.get("IS_AUTOINCREMENT"))) {
//                    test = false;
//                } else if (!masterColumnPropertiesMap.get("DEFAULT_VALUE").equals(destinationColumnPropertiesMap.get("DEFAULT_VALUE"))) {
//                    test = false;
//                }
//                if (!test) {
//                    queries.add(destination.modifyColumnQuery(tableName, column, masterColumnPropertiesMap.get("DATA_TYPE"), masterColumnPropertiesMap.get("COLUMN_SIZE"), masterColumnPropertiesMap.get("DECIMAL_DIGITS"), masterColumnPropertiesMap.get("IS_NULLABLE"), masterColumnPropertiesMap.get("IS_AUTOINCREMENT"), masterColumnPropertiesMap.get("DEFAULT_VALUE")));
//                }
//            }
//        }
//        if (DEBUG) {
//
//            Logs.write("GET ALTER QUERIES FOR EXISTING COLUMNS: ");
//            if (queries.size() > 0) {
//                Enumeration<String> enumerate = queries.elements();
//                while (enumerate.hasMoreElements()) {
//                    Logs.write(enumerate.nextElement());
//                }
//            } else {
//                Logs.write("No Queries Available to Alter Existing Columns");
//            }
//        }
//        return queries;
//    }
    public Vector<String> getAlterQueriesForExistingColumns() throws ClassNotFoundException, SQLException {
        Vector<String> queries = new Vector<String>();
        Vector<String> existingTables = getExistingTables();
        Enumeration<String> tables = existingTables.elements();
        while (tables.hasMoreElements()) {
            String tableName = tables.nextElement();
            Vector<String> existingColumns = getExistingColumnsFromTable(tableName);
            Enumeration<String> columns = existingColumns.elements();
            while (columns.hasMoreElements()) {
                String column = columns.nextElement();
                HashMap<String, String> masterColumnPropertiesMap = master.getColumnProperties(tableName, column);
                HashMap<String, String> destinationColumnPropertiesMap = destination.getColumnProperties(tableName, column);

                if (MainPanel.DEBUG) {
                    Helper.logHashMapData(masterColumnPropertiesMap, destinationColumnPropertiesMap);
                }
                if (!masterColumnPropertiesMap.equals(destinationColumnPropertiesMap)) {
                    queries.add(destination.modifyColumnQuery(tableName, column, masterColumnPropertiesMap.get("DATA_TYPE"), masterColumnPropertiesMap.get("DEFAULT_VALUE"), masterColumnPropertiesMap.get("IS_NULLABLE"), masterColumnPropertiesMap.get("KEY"), masterColumnPropertiesMap.get("EXTRA")));
                }
            }
        }
        if (DEBUG) {

            Logs.write("GET ALTER QUERIES FOR EXISTING COLUMNS: ");
            if (queries.size() > 0) {
                Enumeration<String> enumerate = queries.elements();
                while (enumerate.hasMoreElements()) {
                    Logs.write(enumerate.nextElement());
                }
            } else {
                Logs.write("No Queries Available to Alter Existing Columns");
            }
        }
        return queries;
    }

    public Vector<String> getAlterQueriesForMissingColumns() throws ClassNotFoundException, SQLException {
        Vector<String> queries = new Vector<String>();
        Vector<String> existingTables = getExistingTables();
        Enumeration<String> tables = existingTables.elements();
        while (tables.hasMoreElements()) {
            String tableName = tables.nextElement();

            Vector<String> missingColumns = getMissingColumnsFromTable(tableName);
            Enumeration<String> columns = missingColumns.elements();
            while (columns.hasMoreElements()) {
                String column = columns.nextElement();
                HashMap<String, String> masterColumnPropertiesMap = master.getColumnProperties(tableName, column);
                queries.add(destination.addColumnQuery(tableName, column, masterColumnPropertiesMap.get("DATA_TYPE"), masterColumnPropertiesMap.get("COLUMN_SIZE"), masterColumnPropertiesMap.get("IS_NULLABLE"), masterColumnPropertiesMap.get("IS_AUTOINCREMENT"), masterColumnPropertiesMap.get("DEFAULT_VALUE")));

            }
        }
        if (DEBUG) {
            Logs.write("GET ALTER QUERIES FOR MISSING COLUMNS: ");
            if (queries.size() > 0) {
                Enumeration<String> enumerate = queries.elements();
                while (enumerate.hasMoreElements()) {
                    Logs.write(enumerate.nextElement());

                }
            } else {
                Logs.write("No Queries Available to Alter Missing Columns");
            }
        }
        return queries;
    }

    public Vector<String> getCreateQueriesForMissingTables() throws ClassNotFoundException, SQLException {
        Vector<String> queries = new Vector<String>();
        Vector<String> missingTables = getMissingTables();
        Enumeration<String> tables = missingTables.elements();
        while (tables.hasMoreElements()) {
            String tableName = tables.nextElement();

            queries.add(destination.getCreateQueriesForMissingTables(tableName, master));

        }

        if (DEBUG) {
            Logs.write("GET CREATE QUERIES FOR MISSING TABLES: ");
            Enumeration<String> enumerate = queries.elements();
            while (enumerate.hasMoreElements()) {
                Logs.write(enumerate.nextElement());

            }
        }
        return queries;
    }

    public Vector<String> getAlterQueriesForExistingUniquekeys() throws ClassNotFoundException, SQLException {
        Vector<String> queries = new Vector<String>();
        Vector<String> existingUniqueKeys = getExistingUniqueKeys();
        Enumeration<String> uniqueKeyLists = existingUniqueKeys.elements();
        while (uniqueKeyLists.hasMoreElements()) {
            String constraintName = uniqueKeyLists.nextElement();
            String tableName = master.getTableNameForConstraint(constraintName);
            if (!master.getUniqueKeyColumns(constraintName).equals(destination.getUniqueKeyColumns(constraintName))) {
                queries.addAll(destination.getQueriesToAddModifyUniqueKeys(tableName, constraintName, master.getUniqueKeyColumns(constraintName), true));

            }
        }
        if (DEBUG) {
            Logs.write("GET ALTER QUERIES FOR EXISTING UNIQUE KEYS: ");
            Enumeration<String> enumerate = queries.elements();
            while (enumerate.hasMoreElements()) {
                Logs.write(enumerate.nextElement());
            }
        }
        return queries;

    }

    public Vector<String> getAlterQueriesForMissingUniquekeys() throws ClassNotFoundException, SQLException {
        Vector<String> queries = new Vector<String>();
        Vector<String> missingUniquekeys = getMissingUniqueKeys();
        Enumeration<String> uniqueKeyLists = missingUniquekeys.elements();
        while (uniqueKeyLists.hasMoreElements()) {
            String constraintName = uniqueKeyLists.nextElement();
            String tableName = master.getTableNameForConstraint(constraintName);
            queries.addAll(destination.getQueriesToAddModifyUniqueKeys(tableName, constraintName, master.getUniqueKeyColumns(constraintName), false));

        }
        if (DEBUG) {
            Logs.write("GET ALTER QUERIES FOR MISSING UNIQUE KEYS: ");
            Enumeration<String> enumerate = queries.elements();
            while (enumerate.hasMoreElements()) {
                Logs.write(enumerate.nextElement());
            }
        }
        return queries;
    }

    public Vector<String> getAlterQueriesForMissingPrimaryKeys() throws ClassNotFoundException, SQLException {
        Vector<String> queries = new Vector<String>();
        HashMap<String, String> missingPrimaryKeys = getMissingPrimaryKeys();
        Set<String> missingKeys = missingPrimaryKeys.keySet();
        Iterator<String> itr = missingKeys.iterator();
        while (itr.hasNext()) {
            String tableName = itr.next();
            queries.add(destination.getAlterQueriesToAddPrimaryKeys(tableName, missingPrimaryKeys.get(tableName)));

        }
        if (DEBUG) {
            Logs.write("GET ALTER QUERIES FOR MISSING PRIMARY KEYS: ");
            Enumeration<String> enumerate = queries.elements();
            while (enumerate.hasMoreElements()) {
                Logs.write(enumerate.nextElement());
            }
        }
        return queries;

    }

    public Vector<String> getAlterQueriesForMissingForeignKeys() throws ClassNotFoundException, SQLException {
        Vector<String> queries = new Vector<String>();
        Vector<String> missingForeignKeys = getMissingForeignKeys();
        Enumeration<String> missingKeyList = missingForeignKeys.elements();
        while (missingKeyList.hasMoreElements()) {
            String foreignKey = missingKeyList.nextElement();
            String tableName = master.getTableNameForConstraint(foreignKey);
            queries.add(destination.getAlterQueriesToAddForeignKey(master, tableName, foreignKey));
        }
        if (DEBUG) {
            Logs.write("GET ALTER QUERIES FOR MISSING FOREIGN KEYS: ");
            Enumeration<String> enumerate = queries.elements();
            while (enumerate.hasMoreElements()) {
                Logs.write(enumerate.nextElement());
            }
        }
        return queries;

    }

    public boolean verifyMaster() {
        boolean test = true;
        StringBuilder msg = new StringBuilder();
        if (!InputValidator.isFilled(masterHost)) {
            msg.append("Master Host Address is not provided\n");
            test = false;
        } else if (!InputValidator.isIPReachable(masterHost)) {
            msg.append("Master Host Address is not reachable\n");
            test = false;
        }
        if (!InputValidator.isFilled(masterPort)) {
            msg.append("Master Port is not provided\n");
            test = false;
        }
        if (!InputValidator.isFilled(masterDatabase)) {
            msg.append("Master Database Name is not provided\n");
            test = false;

        }
        if (!InputValidator.isFilled(masterUser)) {
            msg.append("Master User is not provided\n");
            test = false;
        }
        if (!InputValidator.isFilledPassword(masterPassword)) {
            msg.append("Master Password is not provided\n");
            test = false;
        }

        if (!test) {
            JOptionPane.showMessageDialog(null, msg.toString(), "Warning", JOptionPane.WARNING_MESSAGE);


        }
        return test;

    }

    public void saveMasterDetails() {
        try {
            PrintStream out = new PrintStream(new File(PREVIOUS_MASTER_DETAIL));
            out.println("MASTER_TYPE=" + (String) masterDBType.getSelectedItem());
            out.println("MASTER_HOST=" + masterHost.getText());
            out.println("MASTER_PORT=" + masterPort.getText());
            out.println("MASTER_DATABASE=" + masterDatabase.getText());
            out.println("MASTER_USER=" + masterUser.getText());
            out.println("MASTER_PASSWORD=" + new String(masterPassword.getPassword()));
            out.flush();
            out.close();
        } catch (FileNotFoundException fnfe) {
            JOptionPane.showMessageDialog(null, fnfe.getMessage(), "WARNING", JOptionPane.WARNING_MESSAGE);
            Logs.write("Error while saving detail: " + fnfe);


        }
    }

    public void saveDestinationDetails() {
        try {
            PrintStream out = new PrintStream(new File(PREVIOUS_DESTINATION_DETAIL));
            out.println("DESTINATION_TYPE=" + (String) destinationDBType.getSelectedItem());
            out.println("DESTINATION_HOST=" + destinationHost.getText());
            out.println("DESTINATION_PORT=" + destinationPort.getText());
            out.println("DESTINATION_DATABASE=" + destinationDatabase.getText());
            out.println("DESTINATION_USER=" + destinationUser.getText());
            out.println("DESTINATION_PASSWORD=" + new String(destinationPassword.getPassword()));
            out.flush();
            out.close();

        } catch (FileNotFoundException fnfe) {
            JOptionPane.showMessageDialog(null, fnfe.getMessage(), "WARNING", JOptionPane.WARNING_MESSAGE);
            Logs.write("Error while saving detail: " + fnfe);


        }
    }

    public void loadMasterDetails() {
        File f = new File(PREVIOUS_MASTER_DETAIL);
        HashMap<String, String> details = new HashMap<String, String>();

        if (f.exists()) {
            try {
                Scanner in = new Scanner(f);
                while (in.hasNext()) {
                    String line = in.nextLine();
                    StringTokenizer token = new StringTokenizer(line, "=");
                    if (token.countTokens() == 2) {
                        while (token.hasMoreTokens()) {
                            String head = token.nextToken();
                            String value = token.nextToken();
                            details.put(head, value);
                        }
                    }
                }
            } catch (FileNotFoundException fnfe) {
                JOptionPane.showMessageDialog(null, fnfe.getMessage(), "WARNING", JOptionPane.WARNING_MESSAGE);
                Logs.write("Error while reading previous detail: " + fnfe);
            }
            masterDBType.setSelectedItem(details.get("MASTER_TYPE"));
            masterHost.setText(details.get("MASTER_HOST"));
            masterPort.setText(details.get("MASTER_PORT"));
            masterDatabase.setText(details.get("MASTER_DATABASE"));
            masterUser.setText(details.get("MASTER_USER"));
            masterPassword.setText(details.get("MASTER_PASSWORD"));
        }
    }

    public void loadDestinationDetails() {
        File f = new File(PREVIOUS_DESTINATION_DETAIL);
        HashMap<String, String> details = new HashMap<String, String>();
        if (f.exists()) {
            try {
                Scanner in = new Scanner(f);

                while (in.hasNext()) {
                    String line = in.nextLine();
                    StringTokenizer token = new StringTokenizer(line, "=");
                    if (token.countTokens() == 2) {
                        while (token.hasMoreTokens()) {
                            String head = token.nextToken();
                            String value = token.nextToken();
                            details.put(head, value);
                        }
                    }
                }
            } catch (FileNotFoundException fnfe) {
                JOptionPane.showMessageDialog(null, fnfe.getMessage(), "WARNING", JOptionPane.WARNING_MESSAGE);
                Logs.write("Error while reading previous detail: " + fnfe);
            }
            destinationDBType.setSelectedItem(details.get("DESTINATION_TYPE"));
            destinationHost.setText(details.get("DESTINATION_HOST"));
            destinationPort.setText(details.get("DESTINATION_PORT"));
            destinationDatabase.setText(details.get("DESTINATION_DATABASE"));
            destinationUser.setText(details.get("DESTINATION_USER"));
            destinationPassword.setText(details.get("DESTINATION_PASSWORD"));
        }
    }

    public boolean verifyDestination() {
        boolean test = true;
        StringBuilder msg = new StringBuilder();
        if (!InputValidator.isFilled(destinationHost)) {
            msg.append("Destination Host Address is not provided\n");
            test = false;

        } else if (!InputValidator.isIPReachable(destinationHost)) {
            msg.append("Destination Host Address is not reachable\n");
            test = false;
        }
        if (!InputValidator.isFilled(destinationPort)) {
            msg.append("Destination Port is not provided\n");
            test = false;
        }
        if (!InputValidator.isFilled(destinationDatabase)) {
            msg.append("Destination Database Name is not provided\n");
            test = false;
        }
        if (!InputValidator.isFilled(destinationUser)) {
            msg.append("Destination User is not provided\n");
            test = false;

        }
        if (!InputValidator.isFilledPassword(destinationPassword)) {
            msg.append("Destination Password is not provided\n");
            test = false;
        }

        if (!test) {
            JOptionPane.showMessageDialog(null, msg.toString(), "Warning", JOptionPane.WARNING_MESSAGE);

        }
        return test;
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox debug;
    private javax.swing.JComboBox destinationDBType;
    private javax.swing.JTextField destinationDatabase;
    private javax.swing.JTextField destinationHost;
    private javax.swing.JPasswordField destinationPassword;
    private javax.swing.JTextField destinationPort;
    private javax.swing.JButton destinationTest;
    private javax.swing.JTextField destinationUser;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JComboBox masterDBType;
    private javax.swing.JTextField masterDatabase;
    private javax.swing.JTextField masterHost;
    private javax.swing.JPasswordField masterPassword;
    private javax.swing.JTextField masterPort;
    private javax.swing.JButton masterTest;
    private javax.swing.JTextField masterUser;
    private javax.swing.JTabbedPane startCompareForeignKeys;
    private javax.swing.JButton startCompareSchema;
    private javax.swing.JButton startForeignKeyCompare;
    private javax.swing.JButton startPrimaryKeyCompare;
    private javax.swing.JButton startUniqueKeyCompare;
    private javax.swing.JButton startUpgrade;
    private static javax.swing.JLabel status;
    private javax.swing.JProgressBar upgradeProgressBar;
    private javax.swing.JProgressBar upgradeProgressBar1;
    private javax.swing.JProgressBar upgradeProgressBar2;
    private javax.swing.JProgressBar upgradeProgressBar3;
    private javax.swing.JProgressBar upgradeProgressBar4;
    // End of variables declaration//GEN-END:variables
}
